cv.out <- cv.glmnet(as.matrix(train_matrix_df), as.matrix(train.y), alpha = 1)
print(cv.out$lambda.min)
cv.out <- cv.glmnet(as.matrix(train_matrix_df), as.matrix(train.y), alpha = 1)
sel.vars <- predict(cv.out, type="nonzero", s = cv.out$lambda.min)#$X1
print(sel.vars)
cv.out <- cv.glmnet(as.matrix(train_matrix_df), as.matrix(train.y), alpha = 1)
sel.vars <- predict(cv.out, type="nonzero", s = cv.out$lambda.min)#$X1
print(sel.vars)
cv.out <- cv.glmnet(as.matrix(as.matrix(train_matrix_df)[, sel.vars]), as.matrix(train.y), alpha = 0)
cv.out <- cv.glmnet(as.matrix(train_matrix_df), as.matrix(train.y), alpha = 1)
sel.vars <- predict(cv.out, type="nonzero", s = cv.out$lambda.min)$s1
print(sel.vars)
cv.out <- cv.glmnet(as.matrix(as.matrix(train_matrix_df)[, sel.vars]), as.matrix(train.y), alpha = 0)
Ytest.pred <- exp(predict(cv.out, s = cv.out$lambda.min, newx = as.matrix(test_matrix_df[, sel.vars])))
colnames(Ytest.pred)[1]<-"Sale_Price"
ridge_df = data.frame(PID = test.y[1], Sale_Price = Ytest.pred)
write.csv(ridge_df,"data/mysubmission6.txt", row.names = FALSE, quote=FALSE)
pred <- read.csv("data/mysubmission6.txt")
names(test.y)[2] <- "True_Sale_Price"
pred <- merge(pred, test.y, by="PID")
sqrt(mean((log(pred$Sale_Price) - log(pred$True_Sale_Price))^2))
cv.out <- cv.glmnet(as.matrix(train_matrix_df), as.matrix(train.y), alpha = 1)
sel.vars <- predict(cv.out, type="nonzero", s = cv.out$lambda.min)$s1
cv.out <- cv.glmnet(as.matrix(as.matrix(train_matrix_df)[, sel.vars]), as.matrix(train.y), alpha = .2)
Ytest.pred <- exp(predict(cv.out, s = cv.out$lambda.min, newx = as.matrix(test_matrix_df[, sel.vars])))
colnames(Ytest.pred)[1]<-"Sale_Price"
ridge_df = data.frame(PID = test.y[1], Sale_Price = Ytest.pred)
write.csv(ridge_df,"data/mysubmission6.txt", row.names = FALSE, quote=FALSE)
pred <- read.csv("data/mysubmission6.txt")
names(test.y)[2] <- "True_Sale_Price"
pred <- merge(pred, test.y, by="PID")
sqrt(mean((log(pred$Sale_Price) - log(pred$True_Sale_Price))^2))
cv.out <- cv.glmnet(as.matrix(train_matrix_df), as.matrix(train.y), alpha = 1)
sel.vars <- predict(cv.out, type="nonzero", s = cv.out$lambda.min)$s1
cv.out <- cv.glmnet(as.matrix(as.matrix(train_matrix_df)[, sel.vars]), as.matrix(train.y), alpha = .77)
Ytest.pred <- exp(predict(cv.out, s = cv.out$lambda.min, newx = as.matrix(test_matrix_df[, sel.vars])))
colnames(Ytest.pred)[1]<-"Sale_Price"
ridge_df = data.frame(PID = test.y[1], Sale_Price = Ytest.pred)
write.csv(ridge_df,"data/mysubmission6.txt", row.names = FALSE, quote=FALSE)
pred <- read.csv("data/mysubmission6.txt")
names(test.y)[2] <- "True_Sale_Price"
pred <- merge(pred, test.y, by="PID")
sqrt(mean((log(pred$Sale_Price) - log(pred$True_Sale_Price))^2))
library(lubridate)
library(tidyverse)
install.packages("tidyverse")
library(lubridate)
library(tidyverse)
# read raw data and extract date column
train_raw <- readr::read_csv(unz('data/train.csv.zip', 'data/train.csv'))
train_raw <- readr::read_csv(unz('data/train.csv.zip', 'data/train.csv'))
train_raw <- readr::read_csv(unz('data/train.csv.zip', 'train.csv'))
train_raw <- readr::read_csv(unz('train.csv.zip', 'train.csv'))
train_raw <- readr::read_csv(unz('train.csv.zip', 'data/train.csv'))
train_raw <- readr::read_csv(unz('train.csv.zip', 'data/train.csv'))
x = (1:20)/10
print(x)
x = [1, 3, 5]
x = 1, 3, 5
x = c(1, 3, 5)
print(x)
myboosting=function(G, w, x, y){
# G: previous committee
# w: previous weight
# x: covariates
# y: response
# g: current classifier, y=1, if x < split
n = length(x); pos=sample(1:(n-1),1);
g=c(rep(1, pos),rep(-1, n-pos));
err = sum((1-y*g)*w)/2;
alpha=(1/2)*log((1-err)/(err));
G=G+alpha*g
w1 = w*exp(-alpha*y*g); w1 = w1/sum(w1);
list(G=G, w=w,w1=w1, g=sign(alpha)*g, err=min(err,1-err),
split=(x[pos]+x[pos+1])/2, a=alpha)
}
myplot=function(myout, x,y ){
n=length(x); m = sum(y>0);
tmp1=as.vector(t(matrix(c(myout$w,myout$w1), ncol=2)))
tmp2=as.vector(t(matrix(c(x-0.04,x), ncol=2)))
tmp3=as.vector(t(matrix(c(rep(5, n), rep(6, n)),
ncol=2)));
mymax=max(myout$w1, myout$w);
plot(tmp2, tmp1, type="h", lwd=9, col=tmp3, xlim=c(0,2.2),
ylim=c(-mymax/2, mymax+0.05), axes=T,
ylab="weights", xlab="");
points(x[y>0], rep(-mymax/6, m), pch=3)
points(x[y<0], rep(-mymax/6, (n-m)), pch=0)
tmp1=sum(myout$g>0);
points(x[myout$g>0], rep(-mymax/3, tmp1), pch=3)
points(x[myout$g<0], rep(-mymax/3, (n-tmp1)), pch=0)
tmp1=sum(sign(myout$g[1])*sign(myout$g)==1)
tmp2=sum((x[tmp1]+x[tmp1+1])/2)
lines(c(tmp2, tmp2), c(-mymax/2, mymax+0.03), lty=2)
tmp1=sum(myout$G>0);
points(x[myout$G>0], rep(-mymax/2, tmp1), pch=3)
points(x[myout$G<0],rep(-mymax/2, (n-tmp1)),  pch=0)
text(2.15, -mymax/6, "data")
text(2.15, -mymax/3, "current")
text(2.15, -mymax/2,  "overall")
}
#set.seed(100)
x = c(1, 3, 5)
n = length(x);
y= c(-1, 1, -1)
G=rep(0,n); w=rep(1,n)/n;
myout=myboosting(G, w, x, y);
myplot(myout, x,y);
print(myout)
# Libraries
library(glmnet)
# Source: https://www.kaggle.com/code/sarvaninandipati/analysis-prediction-of-walmart-sales-using-r/notebook
# Get Datasets
train <- readr::read_csv('train_ini.csv')
test <- readr::read_csv('test.csv')
# Exploratory Data Analysis
head(train)
dim(train)
class(train)
str(train)
summary(train)
colSums(is.na(train))
#Preprocessing train
train['IsHoliday'] = as.integer(as.logical(train$IsHoliday))
data4 <- train
#formatting date to dd-mm-yyyy
data4$Date <- format(data4$Date, "%d-%m-%Y")
#changing date column in dataframe to date format & arranging in ascending order as per dates
data4$Date <- lubridate::dmy(data4$Date)
data4 <- dplyr::arrange(data4,Date)
#Creating a week number,month,quarter column in dataframe
data4$Week_Number <- lubridate::week(data4$Date)
#adding quarter & month columns
data4$month <- lubridate::month(data4$Date)
data4$quarter <- lubridate::quarter(data4$Date)
##Creating a event type dataframe##
# creating Holiday_date vector
Holiday_date <- c("12-02-2010", "11-02-2011", "10-02-2012", "08-02-2013","10-09-2010", "09-09-2011", "07-09-2012", "06-09-2013","26-11-2010", "25-11-2011", "23-11-2012", "29-11-2013","31-12-2010", "30-12-2011", "28-12-2012", "27-12-2013")
#assigning date format to Holiday_date vector
Holiday_date <- lubridate::dmy(Holiday_date)
#Creating Events vector
Events <-c(rep("Super Bowl", 4), rep("Labor Day", 4),rep("Thanksgiving", 4), rep("Christmas", 4))
#Creating dataframe with Events and date
Holidays_Data <- data.frame(Events,Holiday_date)
#merging both dataframes
data4<-merge(data4,Holidays_Data, by.x= "Date", by.y="Holiday_date", all.x = TRUE)
#Replacing null values in Event with No_Holiday
data4$Events = as.character(data4$Events)
data4$Events[is.na(data4$Events)]= "No_Holiday"
#Drop Unwanted columns and create train.x and train.y
x_train_drop <- c('Date', 'Weekly_Sales')
train.x = data4[,!(names(data4) %in% x_train_drop)]
train.y = train['Weekly_Sales']
#Convert to factor and numeric
train.x$Events <- as.factor(train.x$Events)
train.x$IsHoliday <- as.numeric(train.x$IsHoliday)
train.x$quarter <- as.numeric(train.x$quarter)
#Preprocessing test
test['IsHoliday'] = as.integer(as.logical(test$IsHoliday))
data4 <- test
#formatting date to dd-mm-yyyy
data4$Date <- format(data4$Date, "%d-%m-%Y")
#changing date column in dataframe to date format & arranging in ascending order as per dates
data4$Date <- lubridate::dmy(data4$Date)
data4 <- dplyr::arrange(data4,Date)
#Creating a week number,month,quarter column in dataframe
data4$Week_Number <- lubridate::week(data4$Date)
#adding quarter & month columns
data4$month <- lubridate::month(data4$Date)
data4$quarter <- lubridate::quarter(data4$Date)
##Creating a event type dataframe##
# creating Holiday_date vector
Holiday_date <- c("12-02-2010", "11-02-2011", "10-02-2012", "08-02-2013","10-09-2010", "09-09-2011", "07-09-2012", "06-09-2013","26-11-2010", "25-11-2011", "23-11-2012", "29-11-2013","31-12-2010", "30-12-2011", "28-12-2012", "27-12-2013")
#assigning date format to Holiday_date vector
Holiday_date <- lubridate::dmy(Holiday_date)
#Creating Events vector
Events <-c(rep("Super Bowl", 4), rep("Labor Day", 4),rep("Thanksgiving", 4), rep("Christmas", 4))
#Creating dataframe with Events and date
Holidays_Data <- data.frame(Events,Holiday_date)
#merging both dataframes
data4<-merge(data4,Holidays_Data, by.x= "Date", by.y="Holiday_date", all.x = TRUE)
#Replacing null values in Event with No_Holiday
data4$Events = as.character(data4$Events)
data4$Events[is.na(data4$Events)]= "No_Holiday"
#Drop Unwanted columns and create test.x
x_test_drop <- c('Date', 'Weekly_Sales')
test.x = data4[,!(names(data4) %in% x_test_drop)]
#Convert to factor and numeric
test.x$Events <- as.factor(test.x$Events)
test.x$IsHoliday <- as.numeric(test.x$IsHoliday)
test.x$quarter <- as.numeric(test.x$quarter)
model = lm(formula = as.matrix(train.y) ~ . , data = train.x)
y_pred_train = predict(model, newdata = test.x)
y_pred_train
#Lasso Regression
cv.out = cv.glmnet(data.matrix(train.x), data.matrix(train.y), alpha = 1)
best.lam = cv.out$lambda.min
Ytest.pred = predict(cv.out, s = best.lam, newx = data.matrix(test.x))
# Libraries
library(glmnet)
# Source: https://www.kaggle.com/code/sarvaninandipati/analysis-prediction-of-walmart-sales-using-r/notebook
# Get Datasets
train <- readr::read_csv('train_ini.csv')
test <- readr::read_csv('test.csv')
# Exploratory Data Analysis
head(train)
dim(train)
class(train)
str(train)
summary(train)
colSums(is.na(train))
#Preprocessing train
train['IsHoliday'] = as.integer(as.logical(train$IsHoliday))
data4 <- train
#formatting date to dd-mm-yyyy
data4$Date <- format(data4$Date, "%d-%m-%Y")
#changing date column in dataframe to date format & arranging in ascending order as per dates
data4$Date <- lubridate::dmy(data4$Date)
data4 <- dplyr::arrange(data4,Date)
#Creating a week number,month,quarter column in dataframe
data4$Week_Number <- lubridate::week(data4$Date)
#adding quarter & month columns
data4$month <- lubridate::month(data4$Date)
data4$quarter <- lubridate::quarter(data4$Date)
##Creating a event type dataframe##
# creating Holiday_date vector
Holiday_date <- c("12-02-2010", "11-02-2011", "10-02-2012", "08-02-2013","10-09-2010", "09-09-2011", "07-09-2012", "06-09-2013","26-11-2010", "25-11-2011", "23-11-2012", "29-11-2013","31-12-2010", "30-12-2011", "28-12-2012", "27-12-2013")
#assigning date format to Holiday_date vector
Holiday_date <- lubridate::dmy(Holiday_date)
#Creating Events vector
Events <-c(rep("Super Bowl", 4), rep("Labor Day", 4),rep("Thanksgiving", 4), rep("Christmas", 4))
#Creating dataframe with Events and date
Holidays_Data <- data.frame(Events,Holiday_date)
#merging both dataframes
data4<-merge(data4,Holidays_Data, by.x= "Date", by.y="Holiday_date", all.x = TRUE)
#Replacing null values in Event with No_Holiday
data4$Events = as.character(data4$Events)
data4$Events[is.na(data4$Events)]= "No_Holiday"
#Drop Unwanted columns and create train.x and train.y
x_train_drop <- c('Date', 'Weekly_Sales')
train.x = data4[,!(names(data4) %in% x_train_drop)]
train.y = train['Weekly_Sales']
#Convert to factor and numeric
train.x$Events <- as.factor(train.x$Events)
train.x$IsHoliday <- as.numeric(train.x$IsHoliday)
train.x$quarter <- as.numeric(train.x$quarter)
#Preprocessing test
test['IsHoliday'] = as.integer(as.logical(test$IsHoliday))
data4 <- test
#formatting date to dd-mm-yyyy
data4$Date <- format(data4$Date, "%d-%m-%Y")
#changing date column in dataframe to date format & arranging in ascending order as per dates
data4$Date <- lubridate::dmy(data4$Date)
data4 <- dplyr::arrange(data4,Date)
#Creating a week number,month,quarter column in dataframe
data4$Week_Number <- lubridate::week(data4$Date)
#adding quarter & month columns
data4$month <- lubridate::month(data4$Date)
data4$quarter <- lubridate::quarter(data4$Date)
##Creating a event type dataframe##
# creating Holiday_date vector
Holiday_date <- c("12-02-2010", "11-02-2011", "10-02-2012", "08-02-2013","10-09-2010", "09-09-2011", "07-09-2012", "06-09-2013","26-11-2010", "25-11-2011", "23-11-2012", "29-11-2013","31-12-2010", "30-12-2011", "28-12-2012", "27-12-2013")
#assigning date format to Holiday_date vector
Holiday_date <- lubridate::dmy(Holiday_date)
#Creating Events vector
Events <-c(rep("Super Bowl", 4), rep("Labor Day", 4),rep("Thanksgiving", 4), rep("Christmas", 4))
#Creating dataframe with Events and date
Holidays_Data <- data.frame(Events,Holiday_date)
#merging both dataframes
data4<-merge(data4,Holidays_Data, by.x= "Date", by.y="Holiday_date", all.x = TRUE)
#Replacing null values in Event with No_Holiday
data4$Events = as.character(data4$Events)
data4$Events[is.na(data4$Events)]= "No_Holiday"
#Drop Unwanted columns and create test.x
x_test_drop <- c('Date', 'Weekly_Sales')
test.x = data4[,!(names(data4) %in% x_test_drop)]
#Convert to factor and numeric
test.x$Events <- as.factor(test.x$Events)
test.x$IsHoliday <- as.numeric(test.x$IsHoliday)
test.x$quarter <- as.numeric(test.x$quarter)
model = lm(formula = as.matrix(train.y) ~ . , data = train.x)
y_pred_train = predict(model, newdata = test.x)
#y_pred_train
#Lasso Regression
cv.out = cv.glmnet(data.matrix(train.x), data.matrix(train.y), alpha = 1)
best.lam = cv.out$lambda.min
Ytest.pred = predict(cv.out, s = best.lam, newx = data.matrix(test.x))
View(test.x)
View(train.x)
View(Ytest.pred)
source("mymain.R")
source("mymain.r")
source("mymain.r")
for (t in 1:num_folds) {
# *** THIS IS YOUR PREDICTION FUNCTION ***
test_pred <- mypredict()
# read new data from fold_t
fold_file <- paste0('fold_', t, '.csv')
new_train <- readr::read_csv(fold_file,
col_types = cols())
# extract predictions matching up to the new data
scoring_tbl <- new_train %>%
left_join(test_pred, by = c('Date', 'Store', 'Dept'))
# compute WMAE
actuals <- scoring_tbl$Weekly_Sales
preds <- scoring_tbl$Weekly_Pred
preds[is.na(preds)] <- 0
weights <- if_else(scoring_tbl$IsHoliday, 5, 1)
wae[t] <- sum(weights * abs(actuals - preds)) / sum(weights)
# update train data and get ready to predict at (t+1)
train <- train %>% add_row(new_train)
}
source("mymain.R")
# read new data from fold_t
fold_file <- paste0('fold_', t, '.csv')
# extract predictions matching up to the new data
scoring_tbl <- new_train %>%
left_join(test_pred, by = c('Date', 'Store', 'Dept'))
train <- readr::read_csv('train_ini.csv')
source("mymain.R")
# read in train / test dataframes
train <- readr::read_csv('train_ini.csv')
setwd(../..)
setwd("../..")
setwd("mclop/Desktop/Jupyter Notebooks/project_2/")
source("mymain.R")
# read in train / test dataframes
train <- readr::read_csv('train_ini.csv')
test <- readr::read_csv('test.csv')
# wae: record weighted mean absolute error WMAE
num_folds <- 10
wae <- rep(0, num_folds)
for (t in 1:num_folds) {
# *** THIS IS YOUR PREDICTION FUNCTION ***
test_pred <- mypredict()
# read new data from fold_t
fold_file <- paste0('fold_', t, '.csv')
new_train <- readr::read_csv(fold_file,
col_types = cols())
# extract predictions matching up to the new data
scoring_tbl <- new_train %>%
left_join(test_pred, by = c('Date', 'Store', 'Dept'))
# compute WMAE
actuals <- scoring_tbl$Weekly_Sales
preds <- scoring_tbl$Weekly_Pred
preds[is.na(preds)] <- 0
weights <- if_else(scoring_tbl$IsHoliday, 5, 1)
wae[t] <- sum(weights * abs(actuals - preds)) / sum(weights)
# update train data and get ready to predict at (t+1)
train <- train %>% add_row(new_train)
}
cv.out = cv.glmnet(data.matrix(train.x), data.matrix(train.y), alpha = 1)
best.lam = cv.out$lambda.min
Ytest.pred = predict(cv.out, s = best.lam, newx = data.matrix(test.x))
colnames(Ytest.pred)[1]<-"Weekly_Pred"
View(Ytest.pred)
source("mymain.R")
# read in train / test dataframes
train <- readr::read_csv('train_ini.csv')
test <- readr::read_csv('test.csv')
# wae: record weighted mean absolute error WMAE
num_folds <- 10
wae <- rep(0, num_folds)
for (t in 1:num_folds) {
# *** THIS IS YOUR PREDICTION FUNCTION ***
test_pred <- mypredict()
# read new data from fold_t
fold_file <- paste0('fold_', t, '.csv')
new_train <- readr::read_csv(fold_file,
col_types = cols())
# extract predictions matching up to the new data
scoring_tbl <- new_train %>%
left_join(test_pred, by = c('Date', 'Store', 'Dept'))
# compute WMAE
actuals <- scoring_tbl$Weekly_Sales
preds <- scoring_tbl$Weekly_Pred
preds[is.na(preds)] <- 0
weights <- if_else(scoring_tbl$IsHoliday, 5, 1)
wae[t] <- sum(weights * abs(actuals - preds)) / sum(weights)
# update train data and get ready to predict at (t+1)
train <- train %>% add_row(new_train)
}
source("mymain.R")
# read in train / test dataframes
train <- readr::read_csv('train_ini.csv')
test <- readr::read_csv('test.csv')
# wae: record weighted mean absolute error WMAE
num_folds <- 10
wae <- rep(0, num_folds)
for (t in 1:num_folds) {
# *** THIS IS YOUR PREDICTION FUNCTION ***
test_pred <- mypredict()
# read new data from fold_t
fold_file <- paste0('fold_', t, '.csv')
new_train <- readr::read_csv(fold_file,
col_types = cols())
# extract predictions matching up to the new data
scoring_tbl <- new_train %>%
left_join(test_pred, by = c('Date', 'Store', 'Dept'))
# compute WMAE
actuals <- scoring_tbl$Weekly_Sales
preds <- scoring_tbl$Weekly_Pred
preds[is.na(preds)] <- 0
weights <- if_else(scoring_tbl$IsHoliday, 5, 1)
wae[t] <- sum(weights * abs(actuals - preds)) / sum(weights)
# update train data and get ready to predict at (t+1)
train <- train %>% add_row(new_train)
}
source("mymain.R")
# read in train / test dataframes
train <- readr::read_csv('train_ini.csv')
test <- readr::read_csv('test.csv')
# wae: record weighted mean absolute error WMAE
num_folds <- 10
wae <- rep(0, num_folds)
for (t in 1:num_folds) {
# *** THIS IS YOUR PREDICTION FUNCTION ***
test_pred <- mypredict()
# read new data from fold_t
fold_file <- paste0('fold_', t, '.csv')
new_train <- readr::read_csv(fold_file,
col_types = do.call(cols_only, cols))
# extract predictions matching up to the new data
scoring_tbl <- new_train %>%
left_join(test_pred, by = c('Date', 'Store', 'Dept'))
# compute WMAE
actuals <- scoring_tbl$Weekly_Sales
preds <- scoring_tbl$Weekly_Pred
preds[is.na(preds)] <- 0
weights <- if_else(scoring_tbl$IsHoliday, 5, 1)
wae[t] <- sum(weights * abs(actuals - preds)) / sum(weights)
# update train data and get ready to predict at (t+1)
train <- train %>% add_row(new_train)
}
source("mymain.R")
# read in train / test dataframes
train <- readr::read_csv('train_ini.csv')
test <- readr::read_csv('test.csv')
# wae: record weighted mean absolute error WMAE
num_folds <- 10
wae <- rep(0, num_folds)
for (t in 1:num_folds) {
# *** THIS IS YOUR PREDICTION FUNCTION ***
test_pred <- mypredict()
# read new data from fold_t
fold_file <- paste0('fold_', t, '.csv')
new_train <- readr::read_csv(fold_file,
col_types = do.call(cols_only(), cols()))
# extract predictions matching up to the new data
scoring_tbl <- new_train %>%
left_join(test_pred, by = c('Date', 'Store', 'Dept'))
# compute WMAE
actuals <- scoring_tbl$Weekly_Sales
preds <- scoring_tbl$Weekly_Pred
preds[is.na(preds)] <- 0
weights <- if_else(scoring_tbl$IsHoliday, 5, 1)
wae[t] <- sum(weights * abs(actuals - preds)) / sum(weights)
# update train data and get ready to predict at (t+1)
train <- train %>% add_row(new_train)
}
source("mymain.R")
# read in train / test dataframes
train <- readr::read_csv('train_ini.csv')
test <- readr::read_csv('test.csv')
# wae: record weighted mean absolute error WMAE
num_folds <- 10
wae <- rep(0, num_folds)
for (t in 1:num_folds) {
# *** THIS IS YOUR PREDICTION FUNCTION ***
test_pred <- mypredict()
# read new data from fold_t
fold_file <- paste0('fold_', t, '.csv')
new_train <- readr::read_csv(fold_file,
col_types = cols())
# extract predictions matching up to the new data
scoring_tbl <- new_train %>%
left_join(test_pred, by = c('Date', 'Store', 'Dept'))
# compute WMAE
actuals <- scoring_tbl$Weekly_Sales
preds <- scoring_tbl$Weekly_Pred
preds[is.na(preds)] <- 0
weights <- if_else(scoring_tbl$IsHoliday, 5, 1)
wae[t] <- sum(weights * abs(actuals - preds)) / sum(weights)
# update train data and get ready to predict at (t+1)
train <- train %>% add_row(new_train)
}
source("mymain.R")
# read in train / test dataframes
train <- readr::read_csv('train_ini.csv')
test <- readr::read_csv('test.csv')
# wae: record weighted mean absolute error WMAE
num_folds <- 10
wae <- rep(0, num_folds)
for (t in 1:num_folds) {
# *** THIS IS YOUR PREDICTION FUNCTION ***
test_pred <- mypredict()
# read new data from fold_t
fold_file <- paste0('fold_', t, '.csv')
new_train <- readr::read_csv(fold_file,
col_types = cols())
# extract predictions matching up to the new data
scoring_tbl <- new_train %>%
left_join(test_pred, by = c('Date', 'Store', 'Dept'))
# compute WMAE
actuals <- scoring_tbl$Weekly_Sales
preds <- scoring_tbl$Weekly_Pred
preds[is.na(preds)] <- 0
weights <- if_else(scoring_tbl$IsHoliday, 5, 1)
wae[t] <- sum(weights * abs(actuals - preds)) / sum(weights)
# update train data and get ready to predict at (t+1)
train <- train %>% add_row(new_train)
}
